package loader

import (
    "errors"
    "fmt"
    "os"
    "path/filepath"

    "github.com/cilium/ebpf"
    "github.com/cilium/ebpf/link"
    "github.com/cilium/ebpf/rlimit"
)

// Handle owns loaded BPF objects and the attachment link.
type Handle struct {
    Objects nityObjects
    Link    link.Link
}

// LoadAndAttach loads the dataplane program, attaches it to the given cgroup path,
// and pins all contract maps under pinPath.
//
// cgroupPath examples (kind node):
//   /sys/fs/cgroup
//
// pinPath examples:
//   /sys/fs/bpf/nity
func LoadAndAttach(cgroupPath, pinPath string) (*Handle, error) {
    if err := rlimit.RemoveMemlock(); err != nil {
        // Not fatal on newer kernels (memlock is mostly ignored), but keep it strict.
        return nil, fmt.Errorf("remove memlock: %w", err)
    }

    h := &Handle{}

    // Load objects.
    // NOTE: nityObjects/loadNityObjects are generated by bpf2go into bpf/loader/gen.
    if err := loadNityObjects(&h.Objects, nil); err != nil {
        return nil, fmt.Errorf("load BPF objects: %w", err)
    }

    // Attach connect4.
    lnk, err := link.AttachCgroup(link.CgroupOptions{
        Path:    cgroupPath,
        Attach:  ebpf.AttachCGroupInet4Connect,
        Program: h.Objects.NityConnect4,
    })
    if err != nil {
        _ = h.Objects.Close()
        return nil, fmt.Errorf("attach cgroup/connect4 (%s): %w", cgroupPath, err)
    }
    h.Link = lnk

    // Pin maps.
    if err := pinAllMaps(&h.Objects, pinPath); err != nil {
        _ = h.Link.Close()
        _ = h.Objects.Close()
        return nil, err
    }

    return h, nil
}

// Close detaches and closes resources.
func (h *Handle) Close() error {
    var errs []error
    if h.Link != nil {
        errs = append(errs, h.Link.Close())
    }
    errs = append(errs, h.Objects.Close())
    return errors.Join(errs...)
}

func pinAllMaps(objs *nityObjects, pinPath string) error {
    if pinPath == "" {
        return fmt.Errorf("pinPath is empty")
    }
    if err := os.MkdirAll(pinPath, 0o755); err != nil {
        return fmt.Errorf("mkdir pinPath: %w", err)
    }

    // NOTE: map field names are generated from the ELF map names.
    // These names must match the RFC surface (do not rename maps).
    toPin := []struct {
        name string
        m    *ebpf.Map
    }{
        {"slot_table_A", objs.SlotTableA},
        {"slot_table_B", objs.SlotTableB},
        {"active_table", objs.ActiveTable},
        {"epoch", objs.Epoch},
        {"conntrack_lru", objs.ConntrackLru},
        {"last_agent_seen_ts", objs.LastAgentSeenTs},
        {"rt_control", objs.RtControl},
        {"fallback_size", objs.FallbackSize},
        {"fallback_backends", objs.FallbackBackends},
        {"counters", objs.Counters},
    }

    for _, item := range toPin {
        if item.m == nil {
            return fmt.Errorf("map %s is nil (did bpf2go generate correctly?)", item.name)
        }
        p := filepath.Join(pinPath, item.name)
        // Ignore if already pinned.
        if err := item.m.Pin(p); err != nil {
            // Common case: EEXIST when restarting the agent.
            if !errors.Is(err, os.ErrExist) {
                return fmt.Errorf("pin map %s: %w", item.name, err)
            }
        }
    }

    return nil
}
